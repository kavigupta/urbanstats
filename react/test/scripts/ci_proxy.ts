/**
 * On the test CI, we want to have multiple test runners in parallel.
 *
 * However, pulling down the densitydb repo to run the tests against each time is expensive.
 *
 * So, our strategy will be to serve the local files generated by generate_site.py,
 * and then any files not generated, we'll proxy the request to a CI proxy that has a copy of densitydb.
 */

import express from 'express'
import https from 'https'
import proxy from 'express-http-proxy'
import { Octokit } from 'octokit'
import { z } from 'zod'

const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN })

export async function startProxy(): Promise<void> {
    /**
     * If the user is using a branch that also exists on densitydb, we should use it as well.
     *
     * Otherwise, use `master`
     */
    const targetBranch = z.string().parse(process.env.URBANSTATS_BRANCH_NAME)

    const { data: remoteBranches } = await octokit.rest.repos.listBranches({
        owner: 'densitydb',
        repo: 'densitydb.github.io',
    })

    const branch = remoteBranches.find(({ name }) => name === targetBranch)
        ?? remoteBranches.find(({ name }) => name === 'master')
        ?? (() => { throw new Error('No master branch') })()

    // This is useful for debugging in case the proxy isn't working
    console.warn(`Proxy is using branch ${branch.name} (${branch.commit.sha})`)

    const proxyPath = (req: express.Request) =>
        `/gh/densitydb/densitydb.github.io@${branch.commit.sha}${req.path}`

    const app = express()

    // Do not compress in the proxy; files are already compressed and that can break Range responses.
    app.use((req, res, next) => {
        next(); return
    })

    app.use(express.static('test/density-db'))

    // Range requests: proxy with a raw pipe so the 206 body is byte-identical. express-http-proxy
    // buffers when userResHeaderDecorator is set and can corrupt the body; even without the
    // decorator we saw corruption, so use a minimal manual proxy for Range only.
    app.use((req, res, next) => {
        const range = req.headers.range
        if (!range || typeof range !== 'string') {
            return next()
        }
        const path = proxyPath(req)
        const proxyReq = https.request(
            {
                hostname: 'cdn.jsdelivr.net',
                path,
                method: req.method,
                headers: {
                    ...req.headers,
                    host: 'cdn.jsdelivr.net',
                    connection: 'close',
                },
            },
            (proxyRes) => {
                res.status(proxyRes.statusCode ?? 200)
                const skipHeaders = new Set(['transfer-encoding', 'connection'])
                for (const [name, value] of Object.entries(proxyRes.headers)) {
                    if (value !== undefined && !skipHeaders.has(name.toLowerCase())) {
                        res.setHeader(name, value)
                    }
                }
                proxyRes.pipe(res)
            },
        )
        proxyReq.on('error', (err) => {
            next(err)
        })
        // Range is always GET; no body to send.
        proxyReq.end()
    })

    app.use(
        proxy('https://cdn.jsdelivr.net', {
            proxyReqPathResolver: proxyPath,
            userResHeaderDecorator(headers, userReq) {
                const fileExtension = (/\.(.+)$/.exec(userReq.path))?.[1]
                const mimeType = fileExtension ? { html: 'text/html', js: 'text/javascript' }[fileExtension] : undefined
                // eslint-disable-next-line @typescript-eslint/no-unused-vars, no-restricted-syntax -- We're removing the context-security-policy header via destructuring
                const { 'content-security-policy': _, ...filteredHeaders } = headers
                return {
                    ...filteredHeaders,
                    'content-type': mimeType ?? headers['content-type'],
                }
            },
        }),
    )

    app.listen(8000)
}
